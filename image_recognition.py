# -*- coding: utf-8 -*-
"""image_recognition.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KhWWraneIk0jZAqznaC8SU7HvGoq5Cai

intro

# libraries and folders
"""

import cv2
import os
import numpy as np
from google.colab import drive
from google.colab.patches import cv2_imshow
import json
import torch
from pathlib import Path
from matplotlib import pyplot as plt


# Mount Google Drive
drive.mount('/content/drive')

# Path to the folder containing the images
folder_path = "/content/drive/My Drive/shape_data/images"

# Check if the folder exists
if os.path.exists(folder_path):
    # Get a list of all file names in the folder
    file_names = os.listdir(folder_path)

    # Print the list of file names
    print("Files in the folder:")
    for file_name in file_names:
        print(file_name)
else:
    print("Folder does not exist:", folder_path)

"""# designing the algorithm (classic computer vision technique)"""

def detect_shapes(image):
    # Convert image to grayscale
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    # Apply GaussianBlur to reduce noise
    blurred = cv2.GaussianBlur(gray, (5, 5), 0)

    # Threshold the image to obtain binary image
    _, thresh = cv2.threshold(blurred, 200, 255, cv2.THRESH_BINARY)

    # Find contours in the binary image
    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    # Initialize counters for circles, triangles, and squares
    circle_count = 0
    triangle_count = 0
    square_count = 0

    # Iterate through contours
    for contour in contours:
        # Approximate the contour to reduce the number of points
        epsilon = 0.04 * cv2.arcLength(contour, True)
        approx = cv2.approxPolyDP(contour, epsilon, True)

        # Determine the shape based on the number of vertices
        vertices = len(approx)
        if vertices >= 5:  # If vertices are more than 6, consider it a circle
            circle_count += 1
        elif vertices == 3:  # If vertices are 3, consider it a triangle
            triangle_count += 1
        elif vertices == 4:  # If vertices are 4, consider it a square
            square_count += 1

    return circle_count, triangle_count, square_count


def load_ground_truth(json_file):
    with open(json_file, 'r') as f:
        ground_truth = json.load(f)
    return ground_truth

"""using the algorithm"""

# Path to the JSON file in Google Drive
json_file_path = '/content/drive/My Drive/shape_data/images/ground_truth_mapping.json'

# Load ground truth data from JSON file
ground_truth = load_ground_truth(json_file_path)
total_images = len(ground_truth)
correct_predictions = 0

# Iterate over each file in the folder
for file_name in file_names:
    # Construct the full path to the image file
    file_path = os.path.join(folder_path, file_name)

    # Check if the file is an image (you may want to add additional checks here)
    if file_name.lower().endswith('.png'):
        # Read the image using OpenCV
        image = cv2.imread(file_path)

        # Display the image (optional)
        if image is not None:
            cv2_imshow(image)
            # cv2.imshow("Image", image)
            cv2.waitKey(0)
            cv2.destroyAllWindows()
        else:
            print(f"Failed to read the image: {file_name}")

        # Detect shapes
        circle_count, triangle_count, square_count = detect_shapes(image)
        if (circle_count, triangle_count, square_count) == ground_truth[file_name]:
          correct_predictions += 1

        # Print the counts
        print("Circle count:", circle_count)
        print("Triangle count:", triangle_count)
        print("Square count:", square_count)

# Evaluate performance
accuracy = correct_predictions / total_images

print("")
print('accuarcy :', accuracy)

"""comments:

this method is unable to handle overlapping shapes and will automatically consider overlapping shapes as circles due to the sentinel condition of "6 or more vertices=circle"

the accuracy displays as 0 as i am unable to troubleshoot my error of not being able to count the number of matching anotations between my predicted ones and the truth anotation provided

however, by bruteforce counting, i calculated an accuracy of 29/99 or 29.2%.

# trying out another method
"""

def detect_shapes_v2(image):
    # Convert image to grayscale
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    # Apply GaussianBlur to reduce noise
    blurred = cv2.GaussianBlur(gray, (5, 5), 0)

    # Threshold the image to obtain binary image
    _, thresh = cv2.threshold(blurred, 200, 255, cv2.THRESH_BINARY)

    # Find contours in the binary image
    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    circle_count = 0
    triangle_count = 0
    square_count = 0

    # list for storing names of shapes
    for contour in contours:

        # cv2.approxPloyDP() function to approximate the shape
        approx = cv2.approxPolyDP(
        contour, 0.01 * cv2.arcLength(contour, True), True)


        # counting the shapes for each image
        if len(approx) == 3:
          triangle_count += 1

        elif len(approx) == 4:
          square_count += 1

        else:
          circle_count += 1

    return circle_count, triangle_count, square_count

correct_predictions = 0

# Iterate over each file in the folder
for file_name in file_names:
    # Construct the full path to the image file
    file_path = os.path.join(folder_path, file_name)

    # Check if the file is an image (you may want to add additional checks here)
    if file_name.lower().endswith('.png'):
        # Read the image using OpenCV
        image = cv2.imread(file_path)

        # Display the image (optional)
        if image is not None:
            cv2_imshow(image)
            # cv2.imshow("Image", image)
            cv2.waitKey(0)
            cv2.destroyAllWindows()
        else:
            print(f"Failed to read the image: {file_name}")

        # Detect shapes
        circle_count, triangle_count, square_count = detect_shapes_v2(image)
        if (circle_count, triangle_count, square_count) == ground_truth[file_name]:
          correct_predictions += 1

        # Print the counts
        print("Circle count:", circle_count)
        print("Triangle count:", triangle_count)
        print("Square count:", square_count)

# Evaluate performance
accuracy = correct_predictions / total_images

print("")
print('accuarcy :', accuracy)
